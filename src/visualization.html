<!DOCTYPE html>
<html>
<head>
  <title>RDF Graph Visualization</title>
  <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
  <style type="text/css">
    :root {
      --main-border-color: lightgray;
      --main-bg-color: rgba(240, 240, 240, 0.8);
      --button-bg: #4CAF50;
      --button-hover-bg: #45a049;
      --download-bg: #007bff;
      --download-hover-bg: #0056b3;
      --chat-user-bg: #e3f2fd;
      --chat-assistant-bg: #f5f5f5;
      --highlight-color: #ffeb3b;
      --input-border-color: #ccc;
      --input-radius: 4px;
    }
  
    /* Layout and container */
    body {
      margin: 0;
      padding: 0;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: sans-serif;
      background-color: #fdfdfd;
    }
  
    #mynetwork {
      width: 100%;
      height: 100%;
      border: 1px solid var(--main-border-color);
    }
  
    /* Controls */
    .controls {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 1000;
      padding: 15px;
      background-color: var(--main-bg-color);
      border: 1px solid var(--main-border-color);
      border-radius: var(--input-radius);
      text-align: right;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
  
    .input-group {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      margin-bottom: 5px;
    }
  
    label {
      margin-left: 10px;
      font-size: 0.9rem;
    }
  
    input[type="text"] {
      padding: 8px;
      border: 1px solid var(--input-border-color);
      border-radius: var(--input-radius);
      margin-left: 5px;
      width: 200px;
    }
  
    button {
      padding: 8px 16px;
      background-color: var(--button-bg);
      color: white;
      border: none;
      border-radius: var(--input-radius);
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
  
    button:hover {
      background-color: var(--button-hover-bg);
    }
  
    #downloadButton {
      background-color: var(--download-bg);
    }
  
    #downloadButton:hover {
      background-color: var(--download-hover-bg);
    }
  
    /* Search autocomplete */
    .search-container {
      position: relative;
      width: 100%;
    }
  
    .search-results {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: white;
      border: 1px solid var(--input-border-color);
      border-radius: var(--input-radius);
      max-height: 200px;
      overflow-y: auto;
      z-index: 1001;
      display: none;
    }
  
    .search-result-item {
      padding: 8px;
      cursor: pointer;
      border-bottom: 1px solid #eee;
      transition: background-color 0.2s ease;
    }
  
    .search-result-item:hover {
      background-color: #f0f0f0;
    }
  
    .search-result-item .highlight {
      background-color: var(--highlight-color);
      padding: 2px;
    }
  
    /* Chat interface */
    .chat-container {
      position: absolute;
      top: 550px;
      right: 20px;
      width: 390px;
      height: 400px;
      background-color: rgba(255, 255, 255, 0.95);
      border: 1px solid var(--input-border-color);
      border-radius: var(--input-radius);
      display: flex;
      flex-direction: column;
      z-index: 1000;
      margin-left: 20px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
    }
  
    .chat-messages {
      flex-grow: 1;
      overflow-y: auto;
      padding: 10px;
    }
  
    .chat-input-container {
      display: flex;
      padding: 10px;
      border-top: 1px solid var(--input-border-color);
    }
  
    .chat-input {
      flex-grow: 1;
      padding: 8px;
      border: 1px solid var(--input-border-color);
      border-radius: var(--input-radius);
      margin-right: 8px;
    }
  
    .chat-message {
      margin-bottom: 8px;
      padding: 8px;
      border-radius: var(--input-radius);
    }
  
    .user-message {
      background-color: var(--chat-user-bg);
      margin-left: 20px;
    }
  
    .assistant-message {
      background-color: var(--chat-assistant-bg);
      margin-right: 20px;
    }
  </style>
  
</head>
<body>
  <div id="mynetwork"></div>
  <div class="controls">
    <div class="search-container">
      <input type="text" id="searchInput" placeholder="Search nodes..." style="width: 100%;">
      <div id="searchResults" class="search-results"></div>
    </div>
    <h3>Add New Triple</h3>
    <div class="input-group">
      <label for="subject">Subject:</label>
      <input type="text" id="subject" placeholder="resource1">
    </div>
    <div class="input-group">
      <label for="predicate">Predicate:</label>
      <input type="text" id="predicate" placeholder="knows">
    </div>
    <div class="input-group">
      <label for="object">Object:</label>
      <input type="text" id="object" placeholder="resource2">
    </div>
    <button onclick="addTriple()">Add Triple</button>
    <button id="downloadButton" onclick="downloadGraph()">Download Graph (JSON)</button>
    <input type="file" id="fileInput" accept=".json,.jsonld" style="display: none;" />
    <button onclick="document.getElementById('fileInput').click()">Load JSON-LD File</button>
    <div class="input-group" style="margin-top: 15px;">
      <label for="tripleSlider">Visualize Triples (1-100%):</label>
      <input type="range" id="tripleSlider" min="1" max="100" value="1" style="width: 150px;">
      <span id="tripleCount">100</span>
    </div>
    <div class="input-group" style="margin-top: 10px;">
      <button id="typeFilterButton" onclick="toggleTypeFilter()" style="width: 100%;">Show Only Type/Subclass</button>
    </div>
  </div>
  <div class="chat-container">
    <div class="chat-messages" id="chatMessages"></div>
    <div class="chat-input-container">
      <input type="text" class="chat-input" id="chatInput" placeholder="Ask about the graph...">
      <button onclick="sendMessage()">Send</button>
    </div>
  </div>
  <script type="text/javascript">
    const nodes = new vis.DataSet([]);
    const edges = new vis.DataSet([]);
    const container = document.getElementById('mynetwork');
    const data = { nodes: nodes, edges: edges };
    const options = {
      nodes: { shape: 'dot', size: 15, font: { size: 14 },
        color: { background: '#97C2FC', border: '#2B7CE9', highlight: {background: '#D2E5FF', border: '#2B7CE9' }}},
        edges: { font: { size: 14, align: 'middle' }, color: 'gray', arrows: { to: true }, smooth: false, width: 2 },
        physics: { enabled: true, barnesHut: { gravitationalConstant: -2000, centralGravity: 0.3, springLength: 95, springConstant: 0.04 }, minVelocity: 0.75 }
    };
    const network = new vis.Network(container, data, options);
    const socket = io(`http://localhost:${window.location.port}`);
    let currentGraphData = null;
    let showOnlyTypeTriples = false;

    // Search functionality
    const searchInput = document.getElementById('searchInput');
    const searchResults = document.getElementById('searchResults');
    let searchTimeout = null;

    searchInput.addEventListener('input', function(e) {
      const query = e.target.value.toLowerCase();
      
      // Clear previous timeout
      if (searchTimeout) {
        clearTimeout(searchTimeout);
      }

      // Hide results if query is empty
      if (!query) {
        searchResults.style.display = 'none';
        return;
      }

      // Set a small delay to prevent too frequent updates
      searchTimeout = setTimeout(() => {
        if (!currentGraphData) return;

        const results = [];
        
        // Search in nodes
        currentGraphData.nodes.forEach(node => {
          if (node.label.toLowerCase().includes(query)) {
            results.push({
              type: 'node',
              id: node.id,
              label: node.label
            });
          }
        });

        // Search in edges
        currentGraphData.edges.forEach(edge => {
          if (edge.label.toLowerCase().includes(query)) {
            results.push({
              type: 'edge',
              id: edge.id,
              label: edge.label,
              from: edge.from,
              to: edge.to
            });
          }
        });

        // Display results
        if (results.length > 0) {
          searchResults.innerHTML = results.map(result => {
            const label = result.label;
            const highlightedLabel = label.replace(
              new RegExp(query, 'gi'),
              match => `<span class="highlight">${match}</span>`
            );
            
            return `
              <div class="search-result-item" data-type="${result.type}" data-id="${result.id}">
                ${result.type === 'node' ? 'üîµ' : '‚û°Ô∏è'} ${highlightedLabel}
              </div>
            `;
          }).join('');
          
          searchResults.style.display = 'block';
        } else {
          searchResults.style.display = 'none';
        }
      }, 150);
    });

    // Handle search result clicks
    searchResults.addEventListener('click', function(e) {
      const resultItem = e.target.closest('.search-result-item');
      if (!resultItem) return;

      const type = resultItem.dataset.type;
      const id = resultItem.dataset.id;

      if (type === 'node') {
        // Filter to show only triples involving this node
        const filteredData = {
          nodes: currentGraphData.nodes.filter(node => {
            // Keep the selected node and any nodes connected to it
            return node.id === parseInt(id) || 
                   currentGraphData.edges.some(edge => 
                     (edge.from === parseInt(id) && edge.to === node.id) || 
                     (edge.to === parseInt(id) && edge.from === node.id)
                   );
          }),
          edges: currentGraphData.edges.filter(edge => 
            edge.from === parseInt(id) || edge.to === parseInt(id)
          )
        };

        // Update visualization with filtered data
        nodes.clear();
        edges.clear();
        nodes.add(filteredData.nodes);
        edges.add(filteredData.edges);

        // Focus on the selected node
        network.focus(parseInt(id), {
          scale: 1.5,
          animation: true
        });
      } else {
        // For edges, focus on both connected nodes
        const edge = currentGraphData.edges.find(e => e.id === id);
        if (edge) {
          // Filter to show only triples involving these nodes
          const filteredData = {
            nodes: currentGraphData.nodes.filter(node => {
              return node.id === edge.from || node.id === edge.to || 
                     currentGraphData.edges.some(e => 
                       (e.from === edge.from && e.to === node.id) || 
                       (e.to === edge.from && e.from === node.id) ||
                       (e.from === edge.to && e.to === node.id) || 
                       (e.to === edge.to && e.from === node.id)
                     );
            }),
            edges: currentGraphData.edges.filter(e => 
              e.from === edge.from || e.to === edge.from ||
              e.from === edge.to || e.to === edge.to
            )
          };

          // Update visualization with filtered data
          nodes.clear();
          edges.clear();
          nodes.add(filteredData.nodes);
          edges.add(filteredData.edges);

          network.focus([edge.from, edge.to], {
            scale: 1.5,
            animation: true
          });
        }
      }

      // Hide results after selection
      searchResults.style.display = 'none';
      searchInput.value = '';
    });

    // Close search results when clicking outside
    document.addEventListener('click', function(e) {
      if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
        searchResults.style.display = 'none';
      }
    });

    document.getElementById('fileInput').addEventListener('change', async function(event) {
      const file = event.target.files[0];
      if (file) {
        try {
          const text = await file.text();
          const response = await fetch('/upload', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: text });
          const result = await response.json();
          if (!result.success) alert('Error loading file: ' + result.error);
        } catch (error) {
          console.error('Error:', error);
          alert('Error loading file');
        }
      }
    });

    document.getElementById('tripleSlider').addEventListener('input', function(e) {
      const value = e.target.value;
      document.getElementById('tripleCount').textContent = value;
      if (currentGraphData) {
        updateVisualization(currentGraphData, value);
      }
    });

    function toggleTypeFilter() {
      showOnlyTypeTriples = !showOnlyTypeTriples;
      const button = document.getElementById('typeFilterButton');
      button.textContent = showOnlyTypeTriples ? 'Show All Triples' : 'Show Only Type/Subclass';
      button.style.backgroundColor = showOnlyTypeTriples ? '#FF6B6B' : '#4CAF50';
      
      if (currentGraphData) {
        const sliderValue = document.getElementById('tripleSlider').value;
        updateVisualization(currentGraphData, sliderValue);
      }
    }

    function updateVisualization(data, maxTriplesRatio) {
      nodes.clear();
      edges.clear();

      // Filter edges based on type filter
      let filteredEdges = data.edges;
      if (showOnlyTypeTriples) {
        filteredEdges = data.edges.filter(edge => edge.label === 'rdfs:subClassOf');
      }

      // Calculate how many triples to show based on the slider value
      const totalTriples = filteredEdges.length;
      const triplesToShow = Math.max(1, Math.floor((maxTriplesRatio / 100) * totalTriples));
      // Get the first N triples
      const limitedEdges = filteredEdges.slice(0, triplesToShow);

      // Get all unique nodes from the limited edges
      const nodeIds = new Set();
      limitedEdges.forEach(edge => {
        nodeIds.add(edge.from);
        nodeIds.add(edge.to);
      });

      // Find nodes that occur with rdfs:subClassOf relationships
      const subclassNodeIds = new Set();
      data.edges.forEach(edge => {
        if (edge.label === 'rdfs:subClassOf') {
          subclassNodeIds.add(edge.from);
          subclassNodeIds.add(edge.to);
        }
      });

      // Filter the original nodes based on the nodeIds present in the limited edges
      // and apply coloring based on whether the node is in subclassNodeIds
      const limitedNodes = data.nodes
        .filter(node => nodeIds.has(node.id)) // Only include nodes that are part of the visualized edges
        .map(node => {
          const isSubclassNode = subclassNodeIds.has(node.id);
          return {
            ...node,
            color: isSubclassNode
              ? { // Red color for nodes involved in subclass relationships
                  background: '#FF6B6B',
                  border: '#FF0000',
                  highlight: { background: '#FFB6B6', border: '#FF0000' }
                }
              : { // Default blue color for other nodes
                  background: '#97C2FC',
                  border: '#2B7CE9',
                  highlight: { background: '#D2E5FF', border: '#2B7CE9' }
                }
          };
        });

      // Add nodes first, then edges to ensure all referenced nodes exist
      nodes.add(limitedNodes);
      edges.add(limitedEdges);

      network.fit();
    }

    socket.on('connect', () => { console.log('Connected to WebSocket'); socket.emit('requestGraph'); });
    socket.on('graphData', function(data) {
      currentGraphData = data;
      const sliderValue = document.getElementById('tripleSlider').value;
      updateVisualization(data, sliderValue);
    });

    function addTriple() {
      const subject = document.getElementById('subject').value;
      const predicate = document.getElementById('predicate').value;
      const object = document.getElementById('object').value;

      if (!subject || !predicate || !object) {
        alert('Please fill in all triple fields.');
        return;
      }

      const newTriple = { subject: subject, predicate: predicate, object: object};

      // Send the new triple to the server via WebSocket
      socket.emit('addTriple', newTriple);

      // Clear the input fields
      document.getElementById('subject').value = '';
      document.getElementById('predicate').value = '';
      document.getElementById('object').value = '';
    }

    function downloadGraph() {
      const graphData = {
        nodes: nodes.get(),
        edges: edges.get()
      };
      const jsonString = JSON.stringify(graphData, null, 2);
      const blob = new Blob([jsonString], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'graph.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }

    // Chat functionality
    const chatMessages = document.getElementById('chatMessages');
    const chatInput = document.getElementById('chatInput');

    // Function to add a message to the chat
    function addMessage(message, isUser = false) {
      const messageDiv = document.createElement('div');
      messageDiv.className = `chat-message ${isUser ? 'user-message' : 'assistant-message'}`;
      messageDiv.textContent = message;
      chatMessages.appendChild(messageDiv);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    // Function to send message to OpenAI
    async function sendMessage() {
      const message = chatInput.value.trim();
      if (!message) return;

      // Add user message to chat
      addMessage(message, true);
      chatInput.value = '';

      try {
        const response = await fetch('/chat', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            message,
            currentGraphData,
            functions: [
              {
                name: 'addTriple',
                description: 'Add a new triple to the RDF graph',
                parameters: {
                  type: 'object',
                  properties: {
                    subject: { type: 'string', description: 'Subject of the triple' },
                    predicate: { type: 'string', description: 'Predicate of the triple' },
                    object: { type: 'string', description: 'Object of the triple' }
                  },
                  required: ['subject', 'predicate', 'object']
                }
              },
              {
                name: 'setMaxTriplesRatio',
                description: 'Set the maximum number of triples to display (1-100)',
                parameters: {
                  type: 'object',
                  properties: {
                    ratio: { type: 'number', description: 'Percentage of triples to show (1-100)' }
                  },
                  required: ['ratio']
                }
              },
              {
                name: 'countTriples',
                description: 'Count triples involving a specific node or relation',
                parameters: {
                  type: 'object',
                  properties: {
                    nodeOrRelation: { type: 'string', description: 'The node or relation name to count triples for' }
                  },
                  required: ['nodeOrRelation']
                }
              }
            ]
          })
        });

        const data = await response.json();
        
        if (data.function_call) {
          const result = await handleFunctionCall(data.function_call.name, JSON.parse(data.function_call.arguments));
          addMessage(`Function executed: ${data.function_call.name}\nResult: ${JSON.stringify(result)}`);
        } else if (data.content) {
          addMessage(data.content);
        } else {
          addMessage('No response received from the assistant.');
        }
      } catch (error) {
        console.error('Error:', error);
        addMessage('Sorry, there was an error processing your request.');
      }
    }

    // Function to handle function calls from the LLM
    async function handleFunctionCall(functionName, args) {
      switch (functionName) {
        case 'addTriple':
          const { subject, predicate, object } = args;
          const newTriple = { subject, predicate, object };
          socket.emit('addTriple', newTriple);
          return { success: true, message: 'Triple added successfully' };
        
        case 'setMaxTriplesRatio':
          const { ratio } = args;
          document.getElementById('tripleSlider').value = ratio;
          document.getElementById('tripleCount').textContent = ratio;
          if (currentGraphData) {
            updateVisualization(currentGraphData, ratio);
          }
          return { success: true, message: 'Triple ratio updated successfully' };

        case 'countTriples':
          const { nodeOrRelation } = args;
          if (!currentGraphData) return { success: false, message: 'No graph data available' };
          
          const count = currentGraphData.edges.filter(edge => {
            const node = currentGraphData.nodes.find(n => n.id === edge.from || n.id === edge.to);
            return node.label.includes(nodeOrRelation) || edge.label.includes(nodeOrRelation);
          }).length;
          
          return { 
            success: true, 
            count: count,
            message: `Found ${count} triples involving "${nodeOrRelation}"`
          };
        
        default:
          return { success: false, message: 'Unknown function' };
      }
    }

    // Allow sending message with Enter key
    chatInput.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        sendMessage();
      }
    });
  </script>
</body>
</html>