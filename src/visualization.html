<!DOCTYPE html>
<html>
<head>
  <title>RDF Graph Visualization</title>
  <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
  <style type="text/css">
    #mynetwork {
      width: 100%;
      height: 100%;
      border: 1px solid lightgray;
    }
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .controls {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 1000;
      padding: 15px;
      background-color: rgba(240, 240, 240, 0.8); /* Semi-transparent background */
      border: 1px solid lightgray;
      border-radius: 5px;
      text-align: right; /* Align items to the right within the controls */
      display: flex;
      flex-direction: column; /* Stack elements vertically */
      gap: 10px; /* Space between elements */
    }
    .input-group {
      display: flex;
      justify-content: flex-end; /* Align labels and inputs to the right */
      align-items: center;
      margin-bottom: 5px;
    }
    label {
      margin-left: 10px;
    }
    input[type="text"] {
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      margin-left: 5px;
      width: 200px; /* Adjust width as needed */
    }
    button {
      padding: 8px 16px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background-color: #45a049;
    }
    #downloadButton {
      background-color: #007bff; /* Blue color for download button */
    }
    #downloadButton:hover {
      background-color: #0056b3;
    }
    .search-container {
      position: relative;
      width: 100%;
    }
    .search-results {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: white;
      border: 1px solid #ccc;
      border-radius: 4px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1001;
      display: none;
    }
    .search-result-item {
      padding: 8px;
      cursor: pointer;
      border-bottom: 1px solid #eee;
    }
    .search-result-item:hover {
      background-color: #f0f0f0;
    }
    .search-result-item .highlight {
      background-color: #ffeb3b;
      padding: 2px;
    }
  </style>
</head>
<body>
  <div id="mynetwork"></div>
  <div class="controls">
    <div class="search-container">
      <input type="text" id="searchInput" placeholder="Search nodes..." style="width: 100%;">
      <div id="searchResults" class="search-results"></div>
    </div>
    <h3>Add New Triple</h3>
    <div class="input-group">
      <label for="subject">Subject:</label>
      <input type="text" id="subject" placeholder="resource1">
    </div>
    <div class="input-group">
      <label for="predicate">Predicate:</label>
      <input type="text" id="predicate" placeholder="knows">
    </div>
    <div class="input-group">
      <label for="object">Object:</label>
      <input type="text" id="object" placeholder="resource2">
    </div>
    <button onclick="addTriple()">Add Triple</button>
    <button id="downloadButton" onclick="downloadGraph()">Download Graph (JSON)</button>
    <input type="file" id="fileInput" accept=".json,.jsonld" style="display: none;" />
    <button onclick="document.getElementById('fileInput').click()">Load JSON-LD File</button>
    <div class="input-group" style="margin-top: 15px;">
      <label for="tripleSlider">Visualize Triples (1-100%):</label>
      <input type="range" id="tripleSlider" min="1" max="100" value="1" style="width: 150px;">
      <span id="tripleCount">100</span>
    </div>
    <div class="input-group" style="margin-top: 10px;">
      <button id="typeFilterButton" onclick="toggleTypeFilter()" style="width: 100%;">Show Only Type/Subclass</button>
    </div>
  </div>
  <script type="text/javascript">
    const nodes = new vis.DataSet([]);
    const edges = new vis.DataSet([]);
    const container = document.getElementById('mynetwork');
    const data = { nodes: nodes, edges: edges };
    const options = {
      nodes: { shape: 'dot', size: 15, font: { size: 14 },
        color: { background: '#97C2FC', border: '#2B7CE9', highlight: {background: '#D2E5FF', border: '#2B7CE9' }}},
        edges: { font: { size: 14, align: 'middle' }, color: 'gray', arrows: { to: true }, smooth: false, width: 2 },
        physics: { enabled: true, barnesHut: { gravitationalConstant: -2000, centralGravity: 0.3, springLength: 95, springConstant: 0.04 }, minVelocity: 0.75 }
    };
    const network = new vis.Network(container, data, options);
    const socket = io(`http://localhost:${window.location.port}`);
    let currentGraphData = null;
    let showOnlyTypeTriples = false;

    // Search functionality
    const searchInput = document.getElementById('searchInput');
    const searchResults = document.getElementById('searchResults');
    let searchTimeout = null;

    searchInput.addEventListener('input', function(e) {
      const query = e.target.value.toLowerCase();
      
      // Clear previous timeout
      if (searchTimeout) {
        clearTimeout(searchTimeout);
      }

      // Hide results if query is empty
      if (!query) {
        searchResults.style.display = 'none';
        return;
      }

      // Set a small delay to prevent too frequent updates
      searchTimeout = setTimeout(() => {
        if (!currentGraphData) return;

        const results = [];
        
        // Search in nodes
        currentGraphData.nodes.forEach(node => {
          if (node.label.toLowerCase().includes(query)) {
            results.push({
              type: 'node',
              id: node.id,
              label: node.label
            });
          }
        });

        // Search in edges
        currentGraphData.edges.forEach(edge => {
          if (edge.label.toLowerCase().includes(query)) {
            results.push({
              type: 'edge',
              id: edge.id,
              label: edge.label,
              from: edge.from,
              to: edge.to
            });
          }
        });

        // Display results
        if (results.length > 0) {
          searchResults.innerHTML = results.map(result => {
            const label = result.label;
            const highlightedLabel = label.replace(
              new RegExp(query, 'gi'),
              match => `<span class="highlight">${match}</span>`
            );
            
            return `
              <div class="search-result-item" data-type="${result.type}" data-id="${result.id}">
                ${result.type === 'node' ? 'üîµ' : '‚û°Ô∏è'} ${highlightedLabel}
              </div>
            `;
          }).join('');
          
          searchResults.style.display = 'block';
        } else {
          searchResults.style.display = 'none';
        }
      }, 150);
    });

    // Handle search result clicks
    searchResults.addEventListener('click', function(e) {
      const resultItem = e.target.closest('.search-result-item');
      if (!resultItem) return;

      const type = resultItem.dataset.type;
      const id = resultItem.dataset.id;

      if (type === 'node') {
        // Filter to show only triples involving this node
        const filteredData = {
          nodes: currentGraphData.nodes.filter(node => {
            // Keep the selected node and any nodes connected to it
            return node.id === parseInt(id) || 
                   currentGraphData.edges.some(edge => 
                     (edge.from === parseInt(id) && edge.to === node.id) || 
                     (edge.to === parseInt(id) && edge.from === node.id)
                   );
          }),
          edges: currentGraphData.edges.filter(edge => 
            edge.from === parseInt(id) || edge.to === parseInt(id)
          )
        };

        // Update visualization with filtered data
        nodes.clear();
        edges.clear();
        nodes.add(filteredData.nodes);
        edges.add(filteredData.edges);

        // Focus on the selected node
        network.focus(parseInt(id), {
          scale: 1.5,
          animation: true
        });
      } else {
        // For edges, focus on both connected nodes
        const edge = currentGraphData.edges.find(e => e.id === id);
        if (edge) {
          // Filter to show only triples involving these nodes
          const filteredData = {
            nodes: currentGraphData.nodes.filter(node => {
              return node.id === edge.from || node.id === edge.to || 
                     currentGraphData.edges.some(e => 
                       (e.from === edge.from && e.to === node.id) || 
                       (e.to === edge.from && e.from === node.id) ||
                       (e.from === edge.to && e.to === node.id) || 
                       (e.to === edge.to && e.from === node.id)
                     );
            }),
            edges: currentGraphData.edges.filter(e => 
              e.from === edge.from || e.to === edge.from ||
              e.from === edge.to || e.to === edge.to
            )
          };

          // Update visualization with filtered data
          nodes.clear();
          edges.clear();
          nodes.add(filteredData.nodes);
          edges.add(filteredData.edges);

          network.focus([edge.from, edge.to], {
            scale: 1.5,
            animation: true
          });
        }
      }

      // Hide results after selection
      searchResults.style.display = 'none';
      searchInput.value = '';
    });

    // Close search results when clicking outside
    document.addEventListener('click', function(e) {
      if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
        searchResults.style.display = 'none';
      }
    });

    document.getElementById('fileInput').addEventListener('change', async function(event) {
      const file = event.target.files[0];
      if (file) {
        try {
          const text = await file.text();
          const response = await fetch('/upload', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: text });
          const result = await response.json();
          if (!result.success) alert('Error loading file: ' + result.error);
        } catch (error) {
          console.error('Error:', error);
          alert('Error loading file');
        }
      }
    });

    document.getElementById('tripleSlider').addEventListener('input', function(e) {
      const value = e.target.value;
      document.getElementById('tripleCount').textContent = value;
      if (currentGraphData) {
        updateVisualization(currentGraphData, value);
      }
    });

    function toggleTypeFilter() {
      showOnlyTypeTriples = !showOnlyTypeTriples;
      const button = document.getElementById('typeFilterButton');
      button.textContent = showOnlyTypeTriples ? 'Show All Triples' : 'Show Only Type/Subclass';
      button.style.backgroundColor = showOnlyTypeTriples ? '#FF6B6B' : '#4CAF50';
      
      if (currentGraphData) {
        const sliderValue = document.getElementById('tripleSlider').value;
        updateVisualization(currentGraphData, sliderValue);
      }
    }

    function updateVisualization(data, maxTriplesRatio) {
      nodes.clear();
      edges.clear();

      // Filter edges based on type filter
      let filteredEdges = data.edges;
      if (showOnlyTypeTriples) {
        filteredEdges = data.edges.filter(edge => edge.label === 'rdfs:subClassOf');
      }

      // Calculate how many triples to show based on the slider value
      const totalTriples = filteredEdges.length;
      const triplesToShow = Math.max(1, Math.floor((maxTriplesRatio / 100) * totalTriples));
      // Get the first N triples
      const limitedEdges = filteredEdges.slice(0, triplesToShow);

      // Get all unique nodes from the limited edges
      const nodeIds = new Set();
      limitedEdges.forEach(edge => {
        nodeIds.add(edge.from);
        nodeIds.add(edge.to);
      });

      // Find nodes that occur with rdfs:subClassOf relationships
      const subclassNodeIds = new Set();
      data.edges.forEach(edge => {
        if (edge.label === 'rdfs:subClassOf') {
          subclassNodeIds.add(edge.from);
          subclassNodeIds.add(edge.to);
        }
      });

      // Filter the original nodes based on the nodeIds present in the limited edges
      // and apply coloring based on whether the node is in subclassNodeIds
      const limitedNodes = data.nodes
        .filter(node => nodeIds.has(node.id)) // Only include nodes that are part of the visualized edges
        .map(node => {
          const isSubclassNode = subclassNodeIds.has(node.id);
          return {
            ...node,
            color: isSubclassNode
              ? { // Red color for nodes involved in subclass relationships
                  background: '#FF6B6B',
                  border: '#FF0000',
                  highlight: { background: '#FFB6B6', border: '#FF0000' }
                }
              : { // Default blue color for other nodes
                  background: '#97C2FC',
                  border: '#2B7CE9',
                  highlight: { background: '#D2E5FF', border: '#2B7CE9' }
                }
          };
        });

      // Add nodes first, then edges to ensure all referenced nodes exist
      nodes.add(limitedNodes);
      edges.add(limitedEdges);

      network.fit();
    }

    socket.on('connect', () => { console.log('Connected to WebSocket'); socket.emit('requestGraph'); });
    socket.on('graphData', function(data) {
      currentGraphData = data;
      const sliderValue = document.getElementById('tripleSlider').value;
      updateVisualization(data, sliderValue);
    });

    function addTriple() {
      const subject = document.getElementById('subject').value;
      const predicate = document.getElementById('predicate').value;
      const object = document.getElementById('object').value;

      if (!subject || !predicate || !object) {
        alert('Please fill in all triple fields.');
        return;
      }

      const newTriple = { subject: subject, predicate: predicate, object: object};

      // Send the new triple to the server via WebSocket
      socket.emit('addTriple', newTriple);

      // Clear the input fields
      document.getElementById('subject').value = '';
      document.getElementById('predicate').value = '';
      document.getElementById('object').value = '';
    }

    function downloadGraph() {
      const graphData = {
        nodes: nodes.get(),
        edges: edges.get()
      };
      const jsonString = JSON.stringify(graphData, null, 2);
      const blob = new Blob([jsonString], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'graph.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }
  </script>
</body>
</html>