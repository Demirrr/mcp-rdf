<!DOCTYPE html>
<html>
<head>
  <title>RDF Graph Visualization</title>
  <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
  <style type="text/css">
    #mynetwork {
      width: 100%;
      height: 100%;
      border: 1px solid lightgray;
    }
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .controls {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 1000;
      padding: 15px;
      background-color: rgba(240, 240, 240, 0.8); /* Semi-transparent background */
      border: 1px solid lightgray;
      border-radius: 5px;
      text-align: right; /* Align items to the right within the controls */
      display: flex;
      flex-direction: column; /* Stack elements vertically */
      gap: 10px; /* Space between elements */
    }
    .input-group {
      display: flex;
      justify-content: flex-end; /* Align labels and inputs to the right */
      align-items: center;
      margin-bottom: 5px;
    }
    label {
      margin-left: 10px;
    }
    input[type="text"] {
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      margin-left: 5px;
      width: 200px; /* Adjust width as needed */
    }
    button {
      padding: 8px 16px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background-color: #45a049;
    }
    #downloadButton {
      background-color: #007bff; /* Blue color for download button */
    }
    #downloadButton:hover {
      background-color: #0056b3;
    }
  </style>
</head>
<body>
  <div id="mynetwork"></div>
  <div class="controls">
    <h3>Add New Triple</h3>
    <div class="input-group">
      <label for="subject">Subject:</label>
      <input type="text" id="subject" placeholder="resource1">
    </div>
    <div class="input-group">
      <label for="predicate">Predicate:</label>
      <input type="text" id="predicate" placeholder="knows">
    </div>
    <div class="input-group">
      <label for="object">Object:</label>
      <input type="text" id="object" placeholder="resource2">
    </div>
    <button onclick="addTriple()">Add Triple</button>
    <button id="downloadButton" onclick="downloadGraph()">Download Graph (JSON)</button>
    <input type="file" id="fileInput" accept=".json,.jsonld" style="display: none;" />
    <button onclick="document.getElementById('fileInput').click()">Load JSON-LD File</button>
    <div class="input-group" style="margin-top: 15px;">
      <label for="tripleSlider">Visualize Triples (1-100%):</label>
      <input type="range" id="tripleSlider" min="1" max="100" value="1" style="width: 150px;">
      <span id="tripleCount">100</span>
    </div>
    <div class="input-group" style="margin-top: 10px;">
      <button id="typeFilterButton" onclick="toggleTypeFilter()" style="width: 100%;">Show Only Type/Subclass</button>
    </div>
  </div>
  <script type="text/javascript">
    const nodes = new vis.DataSet([]);
    const edges = new vis.DataSet([]);
    const container = document.getElementById('mynetwork');
    const data = { nodes: nodes, edges: edges };
    const options = {
      nodes: { shape: 'dot', size: 15, font: { size: 14 },
        color: { background: '#97C2FC', border: '#2B7CE9', highlight: {background: '#D2E5FF', border: '#2B7CE9' }}},
        edges: { font: { size: 14, align: 'middle' }, color: 'gray', arrows: { to: true }, smooth: false, width: 2 },
        physics: { enabled: true, barnesHut: { gravitationalConstant: -2000, centralGravity: 0.3, springLength: 95, springConstant: 0.04 }, minVelocity: 0.75 }
    };
    const network = new vis.Network(container, data, options);
    const socket = io(`http://localhost:${window.location.port}`);
    let currentGraphData = null;
    let showOnlyTypeTriples = false;

    document.getElementById('fileInput').addEventListener('change', async function(event) {
      const file = event.target.files[0];
      if (file) {
        try {
          const text = await file.text();
          const response = await fetch('/upload', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: text });
          const result = await response.json();
          if (!result.success) alert('Error loading file: ' + result.error);
        } catch (error) {
          console.error('Error:', error);
          alert('Error loading file');
        }
      }
    });

    document.getElementById('tripleSlider').addEventListener('input', function(e) {
      const value = e.target.value;
      document.getElementById('tripleCount').textContent = value;
      if (currentGraphData) {
        updateVisualization(currentGraphData, value);
      }
    });

    function toggleTypeFilter() {
      showOnlyTypeTriples = !showOnlyTypeTriples;
      const button = document.getElementById('typeFilterButton');
      button.textContent = showOnlyTypeTriples ? 'Show All Triples' : 'Show Only Type/Subclass';
      button.style.backgroundColor = showOnlyTypeTriples ? '#FF6B6B' : '#4CAF50';
      
      if (currentGraphData) {
        const sliderValue = document.getElementById('tripleSlider').value;
        updateVisualization(currentGraphData, sliderValue);
      }
    }

    function updateVisualization(data, maxTriplesRatio) {
      nodes.clear();
      edges.clear();

      // Filter edges based on type filter
      let filteredEdges = data.edges;
      if (showOnlyTypeTriples) {
        filteredEdges = data.edges.filter(edge => edge.label === 'rdfs:subClassOf');
      }

      // Calculate how many triples to show based on the slider value
      const totalTriples = filteredEdges.length;
      const triplesToShow = Math.max(1, Math.floor((maxTriplesRatio / 100) * totalTriples));
      // Get the first N triples
      const limitedEdges = filteredEdges.slice(0, triplesToShow);

      // Get all unique nodes from the limited edges
      const nodeIds = new Set();
      limitedEdges.forEach(edge => {
        nodeIds.add(edge.from);
        nodeIds.add(edge.to);
      });

      // Find nodes that occur with rdfs:subClassOf relationships
      const subclassNodeIds = new Set();
      data.edges.forEach(edge => {
        if (edge.label === 'rdfs:subClassOf') {
          subclassNodeIds.add(edge.from);
          subclassNodeIds.add(edge.to);
        }
      });

      // Filter the original nodes based on the nodeIds present in the limited edges
      // and apply coloring based on whether the node is in subclassNodeIds
      const limitedNodes = data.nodes
        .filter(node => nodeIds.has(node.id)) // Only include nodes that are part of the visualized edges
        .map(node => {
          const isSubclassNode = subclassNodeIds.has(node.id);
          return {
            ...node,
            color: isSubclassNode
              ? { // Red color for nodes involved in subclass relationships
                  background: '#FF6B6B',
                  border: '#FF0000',
                  highlight: { background: '#FFB6B6', border: '#FF0000' }
                }
              : { // Default blue color for other nodes
                  background: '#97C2FC',
                  border: '#2B7CE9',
                  highlight: { background: '#D2E5FF', border: '#2B7CE9' }
                }
          };
        });

      // Add nodes first, then edges to ensure all referenced nodes exist
      nodes.add(limitedNodes);
      edges.add(limitedEdges);

      network.fit();
    }

    socket.on('connect', () => { console.log('Connected to WebSocket'); socket.emit('requestGraph'); });
    socket.on('graphData', function(data) {
      currentGraphData = data;
      const sliderValue = document.getElementById('tripleSlider').value;
      updateVisualization(data, sliderValue);
    });

    function addTriple() {
      const subject = document.getElementById('subject').value;
      const predicate = document.getElementById('predicate').value;
      const object = document.getElementById('object').value;

      if (!subject || !predicate || !object) {
        alert('Please fill in all triple fields.');
        return;
      }

      const newTriple = { subject: subject, predicate: predicate, object: object};

      // Send the new triple to the server via WebSocket
      socket.emit('addTriple', newTriple);

      // Clear the input fields
      document.getElementById('subject').value = '';
      document.getElementById('predicate').value = '';
      document.getElementById('object').value = '';
    }

    function downloadGraph() {
      const graphData = {
        nodes: nodes.get(),
        edges: edges.get()
      };
      const jsonString = JSON.stringify(graphData, null, 2);
      const blob = new Blob([jsonString], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'graph.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }
  </script>
</body>
</html>